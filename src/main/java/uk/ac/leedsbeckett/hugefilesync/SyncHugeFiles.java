/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package uk.ac.leedsbeckett.hugefilesync;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.CopyOption;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.NoSuchAlgorithmException;
import java.util.HashMap;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.apache.http.Header;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.BasicCredentialsProvider;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;

public class SyncHugeFiles implements Runnable
{
  final Properties properties;
  final String username;
  final String password;
  
  final boolean frombb;

  final Path localbase;
  final Path localbatchbase;
  final HashMap<String,Blob> blobmap = new HashMap<>();
  final URI remotebase;
  final Path sourcedir; // if not bb source
  
  final BasicCredentialsProvider credsProvider = new BasicCredentialsProvider();
  CloseableHttpClient httpclient;
  
  int blobcount = 0;
  int filecount = 0;
  int steps = 0;
  int currentstep=1;
  
  SyncHugeFilesListener listener = null;
  Thread thread;
  
  public SyncHugeFiles( Properties properties, SyncHugeFilesListener listener ) throws URISyntaxException
  {
    this( properties );
    this.listener = listener;
  }
  
  public SyncHugeFiles( Properties properties ) throws URISyntaxException
  {
    this.properties = properties;
    localbase = Paths.get( properties.getProperty( "localbasedir" ) );
    localbatchbase = Paths.get( properties.getProperty( "batchsubdir" ) );
    frombb = "bb".equals( properties.getProperty( "from" ) );
    if ( frombb )
    {
      username = properties.getProperty( "remoteusername" );
      password = properties.getProperty( "remotepassword" );
      remotebase = new URI( properties.getProperty( "remotebaseurl" ) );   
      sourcedir = null;
    }
    else
    {
      username = null;
      password = null;
      remotebase = null;
      sourcedir = Paths.get( properties.getProperty( "sourcedir" ) );
    }
  }

  public void start()
  {
    if ( thread != null )
      throw new IllegalArgumentException( "Cannot start process - need to create new processor object, cannot reuse one." );
    thread = new Thread( this );
    thread.start();
  }
  
  public void cancel()
  {
    if ( thread == null )
      throw new IllegalArgumentException( "Cannot cancel process - it has not been started yet." );
    thread.interrupt();
  }
  
  @Override
  public void run()
  {
    if ( listener != null ) listener.syncHugeFilesStarted();
    log( "Started processing" );

    try
    {
      //dummyProcess();
      process();
      log( "Stopping normally" );
      if ( listener != null ) listener.syncHugeFilesStopped( true );
    }
    catch ( Throwable ex )
    {
      log( ex.getMessage() );
      Logger.getLogger(SyncHugeFiles.class.getName()).log(Level.SEVERE, null, ex);
      if ( listener != null ) listener.syncHugeFilesStopped( false );
    }
  }
  
  private void log( String message )
  {
    if ( listener == null )
      System.out.println( message );
    else
      listener.syncHugeFilesLog( message );
  }
  
  public void dummyProcess() throws IOException, NoSuchAlgorithmException, URISyntaxException, InterruptedException
  {
    if ( listener != null ) listener.syncHugeFilesTotalProgress( 0, 10, "Processing" );
    for ( int i = 0; i<10; i++ )
    {
      log( "Starting stage " + (i+1) + " of 10" );
      if ( listener != null ) listener.syncHugeFilesTotalProgress( i, 10, null );
      if ( listener != null ) listener.syncHugeFilesPartProgress( 0, 100, "Starting Download" );
      Thread.sleep( 500 );
      if ( thread.isInterrupted() )
        throw new InterruptedException( "User interrupted process." );
      for ( int j = 1; j<=100; j++ )
      {
        if ( listener != null ) listener.syncHugeFilesPartProgress( j, 100, "Downloading" );
        Thread.sleep( 20 );
        if ( thread.isInterrupted() )
          throw new InterruptedException( "User interrupted process." );
      }
      if ( listener != null ) listener.syncHugeFilesPartProgress( 100, 100, "Downloaded" );
      Thread.sleep( 100 );
    }
    if ( listener != null ) listener.syncHugeFilesTotalProgress( 10, 10, "Processed" );
  }
  
  public void process() throws IOException, NoSuchAlgorithmException, URISyntaxException, InterruptedException
  {
    log( "Starting" );
    loadListing();
    log( "Loaded listing file." );
    if ( listener != null ) listener.syncHugeFilesTotalProgress( currentstep++, steps, "Prepping" );
    
    if ( frombb )
      credsProvider.setCredentials(
            new AuthScope( remotebase.getHost(), "https".equals( remotebase.getScheme() )?443:80 ),
            new UsernamePasswordCredentials( username, password ) );
    
    try
    {
      if ( frombb )
        httpclient = HttpClients.custom().setDefaultCredentialsProvider(credsProvider).build();
      syncBlobs();              
    }
    finally
    {
      if ( frombb )
        if ( httpclient != null )
          httpclient.close();
    }

    if ( listener != null )
    {
      listener.syncHugeFilesTotalProgress( steps, steps, "Complete" );
      listener.syncHugeFilesPartProgress( steps, steps, "Complete" );
    }
    
    System.out.println( "Done" );  
  }

  void loadListing() throws IOException
  {
    try ( Reader in = new FileReader( properties.getProperty( "listingfile" ) ) )
    {
      Iterable<CSVRecord> records = CSVFormat.DEFAULT.parse(in);
      for (CSVRecord record : records)
      {
        String blobdigest = record.get( 1 );
        String source = record.get( 3 );
        String path = record.get( 4 );
        Blob blob = blobmap.get( blobdigest );
        if ( blob == null )
        {
          blob = new Blob( localbase, remotebase, sourcedir, blobdigest );
          blobmap.put( blobdigest, blob );
          blobcount++;
        }
        blob.addFileEntry( new FileEntry( source, path ) );
        filecount++;
      }
    }
    steps = filecount + blobcount + 1;
  }

  void syncBlobs() throws NoSuchAlgorithmException, IOException, URISyntaxException, InterruptedException
  {
    int n = blobmap.size();
    int i=1;
    for ( Blob blob : blobmap.values() )
    {
      log( "Processing blob " + (i++) + " of " + n );
      syncBlob( blob );    
      if ( thread.isInterrupted() )
        throw new InterruptedException( "User interrupted process." );
    }
  }

  void syncBlob( Blob blob ) throws NoSuchAlgorithmException, IOException, URISyntaxException, InterruptedException
  {
    // download the blob if we don't already have it
    if ( listener != null ) listener.syncHugeFilesTotalProgress( currentstep++, steps, "Downloading blob " + blob.blobdigest );
    downloadBlob( blob );
    
    // link files to the blob
    for ( FileEntry file : blob.getFileEntries() )
    {
      String path = file.path;
      if ( path.startsWith( "/" ) )
        path = path.substring( 1 );
      if ( listener != null ) listener.syncHugeFilesTotalProgress( currentstep++, steps, "Downloading " + path );
      Path linkpath = localbatchbase.resolve( path );
      //Path rellink = linkpath.getParent().relativize( blob.localpath );
      if ( !Files.exists( blob.localpath ) )
        throw new IOException( "Blob file doesn't exist so can't link to it." );
      
      // Delete file if it exists already but doesn't link to the blob.
      if ( Files.exists( linkpath ) )
        if ( !Files.isSameFile( linkpath, blob.localpath ) )
          Files.delete( linkpath );
      
      if ( !Files.exists( linkpath ) )
      {
        Files.createDirectories( linkpath.getParent() );
        // Non symbolic (hard) link requires absolute path to target
        Files.createLink( linkpath, blob.localpath );
      }
    }
  }

  void downloadBlob( Blob blob ) throws NoSuchAlgorithmException, IOException, URISyntaxException, InterruptedException
  {    
    if ( Files.exists( blob.localpath ) )
    {
      String md5 = computeMD5( blob.localpath );
      if ( md5.equals( blob.blobdigest ) )
      {
        log( "    Local copy of blob matches source - no need to copy again." );
        return;
      }
      else
        log( "    Local copy of blob does not match and needs to be copied again. " + blob.localpath );
    }

    if ( thread.isInterrupted() )
      throw new InterruptedException( "User interrupted process." );
    
    Path parent = blob.localpath.getParent();
    if ( !Files.exists( parent ) )
      Files.createDirectories( parent );
    
    if ( frombb )
      downloadBlob( blob.uri, blob.localpath );
    else
      copyBlob( blob.sourcepath, blob.localpath );
  }

  void copyBlob( Path source, Path destination ) throws IOException, InterruptedException
  {
    Files.copy(source, destination );
  }
  
  void downloadBlob( URI source, Path destination ) throws IOException, InterruptedException
  {
    final HttpGet httpget = new HttpGet( source );

    log( "    Executing web request " + httpget.getMethod() + " " + source );
    try ( final CloseableHttpResponse response = httpclient.execute(httpget); )
    {
      if ( (response.getStatusLine().getStatusCode() / 100) != 2 )
        throw new IOException( "Unable to fetch data file " + source + " status = " + response.getStatusLine() );

      long length=-1;
      
              
      Header cl = response.getFirstHeader( "Content-Length" );
      if ( cl != null )
      {
        log( "header {" + cl.getValue() + "}" );
        length = Long.parseLong( cl.getValue() );
      }
      
      log( length>=0L?("File length = " + length):"Unknown file length." );
      
      if ( thread.isInterrupted() )
        throw new InterruptedException( "User interrupted process." );

      try ( ListeningOutputStream fout = new ListeningOutputStream( listener, Files.newOutputStream( destination ), length ) )
      {
        response.getEntity().writeTo( fout );
      }
    }
    log( "    Completed normally." );
    
  }
  
  String computeMD5( Path file ) throws NoSuchAlgorithmException, IOException
  { 
    try (InputStream is = Files.newInputStream( file ) )
    {
      return org.apache.commons.codec.digest.DigestUtils.md5Hex(is).toUpperCase();
    }
  }
  

}
